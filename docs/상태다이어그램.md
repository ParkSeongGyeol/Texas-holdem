# 상태 다이어그램 (State Diagram)

**작성자**: 박성결
**작성일**: 2025-10-01
**목적**: 게임 진행 로직의 상태 관리 (FSM) 설계

---

## 📚 목차
1. [게임 페이즈 FSM](#게임-페이즈-fsm)
2. [플레이어 상태 다이어그램](#플레이어-상태-다이어그램)
3. [베팅 라운드 상태 흐름](#베팅-라운드-상태-흐름)
4. [구현 가이드](#구현-가이드)

---

## 게임 페이즈 FSM

### 상태 정의

```python
class GamePhase(Enum):
    """게임 단계"""
    PREFLOP = "preflop"    # 홀 카드 배분 후
    FLOP = "flop"          # 커뮤니티 카드 3장 공개 후
    TURN = "turn"          # 커뮤니티 카드 4장 (1장 추가)
    RIVER = "river"        # 커뮤니티 카드 5장 (1장 추가)
    SHOWDOWN = "showdown"  # 승자 결정
```

### 상태 전이 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                      게임 시작 (new_hand)                    │
└──────────────────────────┬──────────────────────────────────┘
                           ↓
                    ┌─────────────┐
                    │  PREFLOP    │
                    │  (초기 상태) │
                    └──────┬──────┘
                           │ 홀 카드 2장 배분
                           │ 블라인드 베팅
                           │ 베팅 라운드 1
                           ↓
                    ┌─────────────┐
                    │    FLOP     │
                    │ (커뮤니티 3) │
                    └──────┬──────┘
                           │ 번 카드 + 카드 3장 공개
                           │ 베팅 라운드 2
                           ↓
                    ┌─────────────┐
                    │    TURN     │
                    │ (커뮤니티 4) │
                    └──────┬──────┘
                           │ 번 카드 + 카드 1장 공개
                           │ 베팅 라운드 3
                           ↓
                    ┌─────────────┐
                    │   RIVER     │
                    │ (커뮤니티 5) │
                    └──────┬──────┘
                           │ 번 카드 + 카드 1장 공개
                           │ 베팅 라운드 4 (마지막)
                           ↓
                    ┌─────────────┐
                    │  SHOWDOWN   │
                    │  (승자 결정) │
                    └──────┬──────┘
                           │ 패 비교 및 팟 분배
                           ↓
                    ┌─────────────┐
                    │  핸드 종료   │
                    └─────────────┘
                           │
                           ↓ (다음 핸드 시작)
                    (딜러 버튼 이동 → PREFLOP)
```

### 전이 조건

#### PREFLOP → FLOP
- **조건**:
  - 베팅 라운드 종료 (모든 플레이어 베팅액 일치)
  - 2명 이상의 플레이어가 액티브 상태
- **액션**:
  - `deal_flop()` 호출
  - 번 카드 1장 버림
  - 커뮤니티 카드 3장 공개
  - `current_phase = GamePhase.FLOP`

#### FLOP → TURN
- **조건**:
  - 베팅 라운드 종료
  - 2명 이상의 플레이어가 액티브 상태
- **액션**:
  - `deal_turn()` 호출
  - 번 카드 1장 버림
  - 커뮤니티 카드 1장 추가 공개
  - `current_phase = GamePhase.TURN`

#### TURN → RIVER
- **조건**:
  - 베팅 라운드 종료
  - 2명 이상의 플레이어가 액티브 상태
- **액션**:
  - `deal_river()` 호출
  - 번 카드 1장 버림
  - 커뮤니티 카드 1장 추가 공개
  - `current_phase = GamePhase.RIVER`

#### RIVER → SHOWDOWN
- **조건**:
  - 베팅 라운드 종료
  - 2명 이상의 플레이어가 액티브 상태
- **액션**:
  - `current_phase = GamePhase.SHOWDOWN`
  - 패 비교 및 승자 결정

#### 조기 종료 (Early Exit)
- **조건**: 어느 단계에서든 1명만 남고 모두 폴드
- **액션**:
  - 즉시 게임 종료
  - 남은 플레이어가 팟 획득
  - SHOWDOWN 단계 생략

---

## 플레이어 상태 다이어그램

### 상태 정의

```python
class PlayerState:
    is_active: bool      # 게임 참여 가능 여부
    has_folded: bool     # 폴드 여부
    is_all_in: bool      # 올인 여부
    chips: int           # 보유 칩
```

### 상태 전이 다이어그램

```
                    ┌─────────────┐
         게임 시작  │   ACTIVE    │
         ┌─────────▶│ is_active=T │◀──────┐
         │          │ folded=F    │       │
         │          │ all_in=F    │       │
         │          └──────┬──────┘       │
         │                 │              │
         │                 │              │
         │         ┌───────┼───────┐      │
         │         │       │       │      │
         │         │       │       │      │ 새 핸드 시작
         │    Fold │  Bet  │ All-in│      │ (reset)
         │         │       │       │      │
         │         ↓       ↓       ↓      │
         │   ┌─────────┐   │  ┌─────────┐│
         │   │ FOLDED  │   │  │ ALL-IN  ││
         │   │folded=T │   │  │all_in=T ││
         │   │active=F │   │  │active=T* ││
         │   └─────┬───┘   │  └────┬────┘│
         │         │       │       │     │
         │         └───────┴───────┘     │
         │                 │             │
         │                 ↓             │
         │          ┌─────────────┐      │
         │          │ 핸드 종료    │      │
         │          └──────┬──────┘      │
         │                 │             │
         │                 ↓             │
         │          ┌─────────────┐      │
         │     칩>0?│ 상태 리셋    │      │
         └──────YES─┤ reset_for_  ├──────┘
                    │ new_hand()  │
                    └──────┬──────┘
                           │ NO (칩=0)
                           ↓
                    ┌─────────────┐
                    │OUT_OF_CHIPS │
                    │ is_active=F │
                    │ chips=0     │
                    └─────────────┘
                        (게임 제외)
```

### 상태별 허용 액션

| 상태 | Fold | Check | Call | Raise | All-in |
|------|------|-------|------|-------|--------|
| **ACTIVE** | ✅ | ✅* | ✅ | ✅ | ✅ |
| **FOLDED** | ❌ | ❌ | ❌ | ❌ | ❌ |
| **ALL-IN** | ❌ | ✅(자동) | ❌ | ❌ | ❌ |
| **OUT_OF_CHIPS** | ❌ | ❌ | ❌ | ❌ | ❌ |

\* Check는 `current_bet == 0` 일 때만 가능

### 상태 전이 조건

#### ACTIVE → FOLDED
```python
player.fold()
# 효과:
# - has_folded = True
# - is_active = False
# - 해당 핸드에서 제외
```

#### ACTIVE → ALL-IN
```python
player.bet(player.chips)  # 모든 칩 베팅
# 효과:
# - is_all_in = True
# - chips = 0
# - is_active = True (여전히 게임 참여)
# - 이후 베팅 라운드에서 자동 체크
```

#### ACTIVE → ACTIVE (베팅)
```python
player.bet(amount)  # amount < player.chips
# 효과:
# - chips -= amount
# - current_bet += amount
# - 여전히 ACTIVE 상태 유지
```

#### 핸드 종료 → 상태 리셋
```python
if player.chips > 0:
    player.reset_for_new_hand()
    # 다음 핸드에서 ACTIVE 상태로 복귀
else:
    player.is_active = False
    # OUT_OF_CHIPS 상태 (게임 제외)
```

---

## 베팅 라운드 상태 흐름

### 베팅 라운드 FSM

```
┌─────────────────────────────────────────────────┐
│           베팅 라운드 시작                        │
│         (블라인드 또는 베팅 없음)                 │
└──────────────────┬──────────────────────────────┘
                   ↓
            ┌─────────────┐
            │ WAITING     │ ← 현재 플레이어 대기
            │ FOR ACTION  │
            └──────┬──────┘
                   │
        ┌──────────┼──────────┐
        │                     │
   플레이어 액션            타임아웃?
        │                     │
        ↓                     ↓ (자동 폴드)
┌───────────────────┐   ┌─────────────┐
│ ACTION RECEIVED   │   │ AUTO FOLD   │
└────────┬──────────┘   └──────┬──────┘
         │                     │
         └──────────┬──────────┘
                    ↓
            ┌─────────────┐
            │ UPDATE      │
            │ GAME STATE  │
            └──────┬──────┘
                   │
                   ├─ 팟에 베팅 추가
                   ├─ current_bet 갱신
                   └─ 다음 플레이어로 이동
                   │
                   ↓
            ┌─────────────┐
            │ CHECK       │  종료 조건 확인
            │ TERMINATION │
            └──────┬──────┘
                   │
         ┌─────────┼─────────┐
         │                   │
    종료 조건 충족?      계속 진행
         │                   │
         ↓                   ↓
  ┌─────────────┐   ┌─────────────┐
  │ ROUND ENDED │   │ NEXT PLAYER │
  └─────────────┘   └──────┬──────┘
         │                 │
         │                 └─────────┐
         │                           │
         ↓                           ↓
  (다음 게임 페이즈)         (WAITING FOR ACTION)
```

### 베팅 라운드 종료 조건

#### 조건 1: 1명만 남음 (조기 종료)
```python
active_players = [p for p in players if not p.has_folded]
if len(active_players) == 1:
    return True  # 즉시 종료, 남은 플레이어 승리
```

#### 조건 2: 모든 플레이어 베팅액 일치
```python
# 올인한 플레이어 제외하고 베팅액 확인
active_non_allin = [p for p in players
                    if not p.has_folded and not p.is_all_in]

if all(p.current_bet == current_bet for p in active_non_allin):
    # 모든 플레이어가 최소 1번 액션했는지 확인
    if all_players_acted:
        return True  # 베팅 라운드 종료
```

#### 조건 3: 모두 올인
```python
# 폴드하지 않은 플레이어 중 올인하지 않은 사람이 1명 이하
non_folded = [p for p in players if not p.has_folded]
non_allin = [p for p in non_folded if not p.is_all_in]

if len(non_allin) <= 1:
    return True  # 더 이상 베팅 불가, 남은 카드 모두 공개
```

### 베팅 순서

#### 프리플롭 (PREFLOP)
```
2인 게임:
1. 딜러/스몰 블라인드 먼저 액션
2. 빅 블라인드 액션
3. 딜러 → 빅 블라인드 순서로 반복
```

#### 플롭/턴/리버 (FLOP/TURN/RIVER)
```
2인 게임:
1. 빅 블라인드(논-딜러) 먼저 액션
2. 딜러 액션
3. 빅 블라인드 → 딜러 순서로 반복
```

### 베팅 라운드 의사코드

```python
def betting_round(game, starting_player_index):
    current_player_idx = starting_player_index
    last_raiser = None
    all_players_acted = False

    while not is_round_over(game):
        player = game.players[current_player_idx]

        # 스킵 조건
        if player.has_folded or player.is_all_in:
            current_player_idx = next_player(current_player_idx)
            continue

        # 액션 받기
        action, amount = get_player_action(player, game)

        # 액션 처리
        if action == Action.FOLD:
            player.fold()
        elif action == Action.CHECK:
            pass  # 아무 것도 안 함
        elif action == Action.CALL:
            call_amount = game.current_bet - player.current_bet
            player.bet(call_amount)
            game.pot += call_amount
        elif action == Action.RAISE:
            raise_amount = amount - player.current_bet
            player.bet(raise_amount)
            game.pot += raise_amount
            game.current_bet = player.current_bet
            last_raiser = current_player_idx
        elif action == Action.ALL_IN:
            all_in_amount = player.chips
            player.bet(all_in_amount)
            game.pot += all_in_amount
            if player.current_bet > game.current_bet:
                game.current_bet = player.current_bet
                last_raiser = current_player_idx

        # 다음 플레이어
        current_player_idx = next_player(current_player_idx)

        # 한 바퀴 돌았는지 확인
        if current_player_idx == starting_player_index:
            all_players_acted = True

    # 라운드 종료 후 베팅 리셋
    for player in game.players:
        player.current_bet = 0
    game.current_bet = 0
```

---

## 구현 가이드

### 1. 게임 페이즈 관리

#### game.py 구현
```python
class PokerGame:
    def __init__(self):
        self.current_phase = GamePhase.PREFLOP
        # ...

    def advance_phase(self):
        """다음 게임 단계로 이동"""
        if self.current_phase == GamePhase.PREFLOP:
            self.deal_flop()
            self.current_phase = GamePhase.FLOP
        elif self.current_phase == GamePhase.FLOP:
            self.deal_turn()
            self.current_phase = GamePhase.TURN
        elif self.current_phase == GamePhase.TURN:
            self.deal_river()
            self.current_phase = GamePhase.RIVER
        elif self.current_phase == GamePhase.RIVER:
            self.current_phase = GamePhase.SHOWDOWN
            self.showdown()

    def is_hand_over(self) -> bool:
        """핸드 종료 확인"""
        active_count = sum(1 for p in self.players if not p.has_folded)
        return active_count <= 1
```

### 2. 플레이어 상태 관리

#### player.py 구현
```python
class Player:
    def get_state(self) -> str:
        """현재 상태 문자열 반환"""
        if not self.is_active:
            if self.chips == 0:
                return "OUT_OF_CHIPS"
            return "INACTIVE"
        if self.has_folded:
            return "FOLDED"
        if self.is_all_in:
            return "ALL_IN"
        return "ACTIVE"

    def can_act(self) -> bool:
        """액션 가능 여부"""
        return self.is_active and not self.has_folded and not self.is_all_in
```

### 3. 베팅 라운드 관리

#### game.py에 추가
```python
def run_betting_round(self, starting_position: int):
    """베팅 라운드 실행"""
    current_idx = starting_position
    players_acted = {i: False for i in range(len(self.players))}

    while True:
        player = self.players[current_idx]

        # 액션 가능한 플레이어만
        if player.can_act():
            action, amount = self.get_action(player)
            self.process_action(player, action, amount)
            players_acted[current_idx] = True

        # 종료 조건 확인
        if self.is_betting_round_over(players_acted):
            break

        # 다음 플레이어
        current_idx = (current_idx + 1) % len(self.players)

    # 라운드 종료 정리
    for player in self.players:
        player.current_bet = 0
    self.current_bet = 0

def is_betting_round_over(self, players_acted: dict) -> bool:
    """베팅 라운드 종료 확인"""
    # 1명만 남음
    active = [p for p in self.players if not p.has_folded]
    if len(active) == 1:
        return True

    # 모든 활성 플레이어가 액션했고 베팅액 일치
    for i, player in enumerate(self.players):
        if player.can_act() and not players_acted[i]:
            return False
        if not player.has_folded and not player.is_all_in:
            if player.current_bet != self.current_bet:
                return False

    return True
```

---

## 참고 자료

### 관련 파일
- `src/core/game.py` - 게임 페이즈 및 베팅 라운드 구현
- `src/core/player.py` - 플레이어 상태 관리
- `docs/게임규칙.md` - 게임 규칙 상세 설명
- `docs/게임플로우.md` - 전체 게임 흐름

### 상태 관리 체크리스트
- [ ] GamePhase Enum 정의 완료
- [ ] 게임 페이즈 전이 로직 구현
- [ ] 플레이어 상태 관리 메서드 구현
- [ ] 베팅 라운드 종료 조건 구현
- [ ] 조기 종료 처리 구현
- [ ] 상태별 허용 액션 검증 로직

---

**문서 버전**: 1.0
**최종 수정**: 2025-10-01
