<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>텍사스 홀덤 통합 셸 UI</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'poker-green': '#006400',
                        'poker-dark': '#1a1a1a',
                        'card-bg': '#fefefe',
                        'chip-red': '#dc2626',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* 포커 테이블 모양을 위한 기본 스타일 */
        #poker-table {
            background-color: #388e3c; /* 포커 테이블 녹색 */
            border-radius: 50% / 30%; /* 타원형 테이블 모양 */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5) inset;
            border: 10px solid #212121;
            position: relative;
        }

        /* 카드 스타일 */
        .card {
            width: 55px;
            height: 80px;
            background-color: var(--card-bg);
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        .card-back {
            background-color: #c00;
            border: 2px solid gold;
            color: transparent;
        }

        /* 플레이어 위치 - UI 겹침 방지를 위해 위치 조정 */
        .player-area {
            position: absolute;
            width: 140px;
            text-align: center;
            z-index: 10;
        }
        .player-0 { bottom: 5px; left: 50%; transform: translateX(-50%); } 
        .player-1 { top: 15%; right: 10%; }
        .player-2 { top: 15%; left: 10%; }
        .player-3 { bottom: 5px; right: 10%; } 
    </style>
</head>
<body class="bg-poker-dark text-white font-sans min-h-screen p-4 flex flex-col items-center justify-center">

    <div class="w-full max-w-5xl flex flex-col items-center">

        <!-- 1. 게임 시작 화면 (로비) -->
        <div id="start-screen" class="p-8 bg-gray-800 rounded-xl shadow-2xl text-center transition-opacity duration-500 w-full max-w-xl">
            <h1 class="text-4xl font-extrabold text-yellow-500 mb-6">텍사스 홀덤 UI 셸</h1>
            <p class="text-lg text-gray-300 mb-8">난이도 선택은 UI 기능만 시뮬레이션. (실제 로직은 팀원 코드로 교체 예정)</p>
            
            <h2 class="text-2xl font-semibold mb-4 text-white">난이도 설정</h2>
            <div id="difficulty-selection" class="flex justify-center space-x-4 mb-10">
                <button data-difficulty="easy" class="difficulty-btn px-6 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold transition duration-150 shadow-lg border-2 border-transparent">쉬움</button>
                <button data-difficulty="medium" class="difficulty-btn px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold transition duration-150 shadow-lg border-2 border-transparent">중간</button>
                <button data-difficulty="hard" class="difficulty-btn px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-bold transition duration-150 shadow-lg border-2 border-transparent">어려움</button>
            </div>

            <button id="start-game-button" class="px-10 py-4 bg-yellow-500 hover:bg-yellow-600 text-gray-900 text-xl font-extrabold rounded-xl shadow-2xl transition duration-200 transform hover:scale-105" disabled>
                UI 시뮬레이션 시작
            </button>
            <p id="difficulty-status" class="mt-4 text-sm text-yellow-300">난이도를 선택해 주세요.</p>
        </div>

        <!-- 2. 게임 플레이 화면 (초기에는 숨김) -->
        <div id="game-screen" class="hidden w-full max-w-5xl flex flex-col items-center">
            
            <!-- 포커 테이블 (타원형) -->
            <div id="poker-table" class="w-full h-[550px] relative p-10 max-w-4xl mb-24"> 

                <!-- Pot 및 메시지 영역 -->
                <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20 text-center space-y-3">
                    <div class="text-xl font-bold bg-yellow-700/80 p-2 rounded-lg shadow-lg">
                        팟 (Pot): <span id="pot-amount" class="text-yellow-300">0</span>
                    </div>
                    <div id="game-message" class="text-lg text-white font-semibold"></div>
                </div>

                <!-- 커뮤니티 카드 영역 -->
                <div id="community-cards" class="absolute left-1/2 transform -translate-x-1/2 flex space-x-2 z-20" style="top: 15%;">
                    <!-- 커뮤니티 카드가 여기에 렌더링됩니다 -->
                </div>

                <!-- 플레이어 영역 (4명) -->
                <div id="player-container">
                    <!-- JavaScript로 플레이어 정보가 렌더링됩니다 -->
                </div>
                
            </div>
            
            <!-- 액션 버튼 (사용자 전용) - 테이블 외부로 분리 -->
            <div id="action-controls" class="w-full max-w-lg mt-4 p-4 bg-poker-dark rounded-xl shadow-2xl transition-all">
                <div id="action-buttons" class="flex justify-center space-x-3">
                    <button onclick="handleAction('fold')" class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-bold transition duration-150 shadow-md">
                        <i class="fas fa-hand-paper"></i> 폴드 (Fold)
                    </button>
                    <button onclick="handleAction('call')" class="px-6 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold transition duration-150 shadow-md">
                        <span id="call-check-label">콜 (Call) / 체크 (Check)</span>
                    </button>
                    <button onclick="document.getElementById('bet-panel').classList.toggle('hidden')" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold transition duration-150 shadow-md">
                        베팅 / 레이즈
                    </button>
                </div>

                <!-- 베팅/레이즈 컨트롤 패널 -->
                <div id="bet-panel" class="hidden mt-3 p-3 bg-gray-700/80 rounded-lg flex flex-col space-y-2">
                    <div class="flex items-center space-x-2">
                        <!-- 슬라이더는 UI 입력 요소의 역할을 합니다. -->
                        <input type="range" id="bet-slider" min="0" max="5000" value="0" step="50" class="w-full">
                        <input type="number" id="bet-amount" value="0" min="0" class="w-20 p-1 text-center bg-gray-900 rounded text-white">
                    </div>
                    <button onclick="handleAction('raise')" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-bold">
                        <span id="raise-label">0</span> 베팅 실행 (Placeholder)
                    </button>
                </div>

                <!-- 게임 진행 버튼 (통합 후에는 백엔드/API가 처리) -->
                <div class="mt-4 pt-4 border-t border-gray-600 flex justify-center">
                    <button onclick="advanceGamePhase()" id="next-phase-button" class="px-6 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold transition duration-150 shadow-md">
                        다음 단계로 (Placeholder)
                    </button>
                </div>
            </div>


            <div id="game-log" class="w-full max-w-4xl mt-4 p-3 h-20 bg-poker-dark/70 rounded-lg overflow-y-auto text-sm">
                <!-- 로그 메시지가 여기에 표시됩니다. -->
            </div>
        </div>

    </div>

    <!-- Font Awesome (아이콘용) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>
    
    <script>
        // --- 1. 더미 데이터 (팀원들의 실제 데이터로 교체될 부분) ---

        // 플레이어 클래스 정의 (UI 렌더링을 위한 기본 구조)
        class Player {
            constructor(name, chips, index, isUser = false) {
                this.name = name;
                this.chips = chips;
                this.index = index;
                this.isUser = isUser;
                this.current_bet = 0;
                this.hand = [];
                this.has_folded = false;
                this.is_all_in = false;
            }
        }

        // UI 렌더링에 사용될 가짜 데이터
        const DUMMY_INITIAL_STATE = {
            pot: 300,
            currentRequiredBet: 200,
            gamePhase: 'preflop', // 'preflop', 'flop', 'turn', 'river', 'showdown'
            activePlayerIndex: 0, // 사용자 턴
            players: [
                new Player("나 (User)", 4800, 0, true),
                new Player("AI Alice", 4700, 1),
                new Player("AI Bob", 5000, 2),
                new Player("AI Charlie", 5200, 3),
            ],
            // 이 카드는 백엔드에서 받아와야 합니다. 현재는 UI 테스트용 더미입니다.
            communityCards: [], 
        };

        // 사용자 카드 (더미)
        DUMMY_INITIAL_STATE.players[0].hand = [{ rank: 'A', suit: 'H' }, { rank: 'K', suit: 'C' }];
        // AI 카드 (숨겨진 더미)
        DUMMY_INITIAL_STATE.players[1].hand = [{}, {}]; 
        DUMMY_INITIAL_STATE.players[2].hand = [{}, {}];
        DUMMY_INITIAL_STATE.players[3].hand = [{}, {}];
        
        // 현재 게임 상태 (UI는 항상 이 상태를 기반으로 렌더링됩니다)
        let gameState = { ...DUMMY_INITIAL_STATE, screen: 'start', difficulty: null };

        // 칩 및 베팅액 포맷
        const formatChips = (amount) => amount.toLocaleString('ko-KR');

        // 카드 HTML 생성 함수 (UI 전용)
        function getCardHTML(card, isHidden = false) {
            if (!card || isHidden) {
                return `<div class="card card-back bg-gray-500 shadow-md"></div>`;
            }
            // rank와 suit만 있다면 UI는 정상적으로 렌더링됩니다.
            const suitColor = (card.suit === 'H' || card.suit === 'D') ? 'text-red-600' : 'text-black';
            const suitSymbol = { 'H': '♥', 'D': '♦', 'C': '♣', 'S': '♠' }[card.suit];

            return `
                <div class="card bg-card-bg ${suitColor} shadow-lg flex-col justify-between p-1">
                    <span class="text-sm self-start leading-none">${card.rank}</span>
                    <span class="text-xl">${suitSymbol}</span>
                    <span class="text-sm self-end leading-none transform rotate-180">${card.rank}</span>
                </div>
            `;
        }

        // --- 2. 백엔드 통합 자리 표시자 (Placeholder Functions) ---
        // !!! 주의: 팀원들의 코드를 연결할 때 이 함수들의 내부 로직을 전부 교체해야 합니다. !!!

        /**
         * [PLACEHOLDER] 백엔드에 초기화 요청을 보내고 초기 상태를 받아옵니다.
         * 통합 후: 게임 서버에 '/api/start_game' 요청을 보내는 코드로 교체합니다.
         */
        async function initializeBackend(difficulty) {
            console.log(`[INTEGRATION] 백엔드 초기화 요청: 난이도 ${difficulty}`);
            
            // 임시로 더미 상태를 반환
            return new Promise(resolve => {
                setTimeout(() => {
                    const newPlayers = DUMMY_INITIAL_STATE.players.map(p => new Player(p.name, p.chips, p.index, p.isUser));
                    // 사용자에게 콜할 금액을 설정
                    newPlayers[0].current_bet = 100; 
                    newPlayers[1].current_bet = DUMMY_INITIAL_STATE.currentRequiredBet; 
                    
                    const initialState = {
                        ...DUMMY_INITIAL_STATE,
                        players: newPlayers,
                        difficulty: difficulty,
                        gamePhase: 'preflop',
                        // AI 턴이었다고 가정하고 사용자에게 턴이 넘어온 상태를 모방
                        activePlayerIndex: 0, 
                    };
                    resolve(initialState);
                }, 500);
            });
        }

        /**
         * [PLACEHOLDER] 사용자 액션을 백엔드에 전송하고 새로운 상태를 받아옵니다.
         * 통합 후: 게임 서버에 '/api/action' 요청을 보내는 코드로 교체합니다.
         */
        async function sendAction(actionType, amount = 0) {
            console.log(`[INTEGRATION] 액션 전송: ${actionType}, 금액: ${amount}`);
            
            // 임시로 UI 상태만 가짜로 업데이트하고 다음 턴 상태를 모방합니다.
            const user = gameState.players.find(p => p.isUser);
            if (user) {
                const amountToCall = gameState.currentRequiredBet - user.current_bet;
                
                switch(actionType) {
                    case 'fold':
                        user.has_folded = true;
                        break;
                    case 'call':
                        user.chips -= amountToCall;
                        user.current_bet += amountToCall;
                        gameState.pot += amountToCall;
                        break;
                    case 'raise':
                        // 레이즈는 총 베팅액을 기준으로 업데이트
                        user.chips -= amount;
                        gameState.pot += amount;
                        gameState.currentRequiredBet = amount;
                        user.current_bet = amount;
                        break;
                }
            }
            
            // AI 턴은 백엔드에서 처리되었다고 가정하고 다음 단계 상태를 반환합니다.
            return new Promise(resolve => {
                 setTimeout(() => {
                    // 다음 상태 (예: AI들이 모두 콜한 후의 상태)
                    const nextState = { ...gameState };
                    nextState.players.forEach((p, i) => {
                        if (!p.isUser) {
                            // AI들은 콜을 했다고 가정
                            const callAmt = gameState.currentRequiredBet - p.current_bet;
                            p.chips -= callAmt;
                            p.current_bet += callAmt;
                            nextState.pot += callAmt;
                        }
                    });
                    
                    // 다음 액티브 플레이어는 사용자 자신 또는 다음 단계로 넘어갈 준비가 된 상태
                    nextState.activePlayerIndex = 0; 
                    resolve(nextState);

                 }, 1000); // 1초 지연 시뮬레이션
            });
        }

        /**
         * [PLACEHOLDER] 다음 게임 단계 (Flop, Turn, River)로 진행 요청을 보냅니다.
         * 통합 후: 게임 서버에 '/api/advance_phase' 요청을 보내는 코드로 교체합니다.
         */
        async function advanceGamePhaseBackend() {
            console.log(`[INTEGRATION] 다음 단계 진행 요청: 현재 단계 ${gameState.gamePhase}`);
            
            // 임시로 다음 단계를 위한 더미 카드를 제공합니다.
            let nextPhase = '';
            let newCards = [];
            let nextPot = gameState.pot;

            // 베팅액 리셋은 백엔드에서 처리되어야 합니다.
            gameState.players.forEach(p => p.current_bet = 0);
            gameState.currentRequiredBet = 0;

            switch(gameState.gamePhase) {
                case 'preflop':
                    nextPhase = 'flop';
                    newCards = [{ rank: 'K', suit: 'H' }, { rank: '5', suit: 'D' }, { rank: 'A', suit: 'C' }];
                    break;
                case 'flop':
                    nextPhase = 'turn';
                    newCards = [...gameState.communityCards, { rank: '2', suit: 'S' }];
                    break;
                case 'turn':
                    nextPhase = 'river';
                    newCards = [...gameState.communityCards, { rank: 'Q', suit: 'H' }];
                    break;
                case 'river':
                    nextPhase = 'showdown';
                    newCards = gameState.communityCards;
                    nextPot += 1000; // 쇼다운 시 임의의 팟 증가 시뮬레이션
                    break;
                case 'showdown':
                default:
                    // 다시 시작을 위해 초기 상태로 돌아갑니다.
                    return initializeBackend(gameState.difficulty);
            }
            
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve({
                        ...gameState,
                        gamePhase: nextPhase,
                        communityCards: newCards,
                        pot: nextPot,
                        // 다음 베팅 라운드 시작 시 사용자에게 턴이 돌아왔다고 가정
                        activePlayerIndex: 0 
                    });
                }, 1500);
            });
        }
        
        // --- 3. UI 컨트롤러 (화면 표시 및 액션 전달) ---

        // 게임 시작 (버튼 클릭 시)
        async function startGame() {
            if (!gameState.difficulty) return;
            
            // 1. [Placeholder 호출] 백엔드 초기화 요청
            const initialState = await initializeBackend(gameState.difficulty);
            
            // 2. UI 상태 업데이트
            gameState = { ...initialState, screen: 'game' };
            
            // 3. UI 렌더링
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            renderGameUI();
            
            logMessage(`난이도: ${gameState.difficulty}로 UI 시뮬레이션을 시작합니다. (백엔드 통합 필요)`, 'yellow');
        }
        
        // 사용자 액션 처리 (버튼 클릭 시)
        async function handleAction(actionType) {
            const user = gameState.players.find(p => p.isUser);
            if (!user) return;

            let amount = 0;
            if (actionType === 'raise') {
                amount = parseInt(document.getElementById('bet-amount').value, 10);
            }

            logMessage(`사용자 액션: ${actionType} (금액: ${formatChips(amount)})`, 'blue');

            // 1. [Placeholder 호출] 액션 정보를 백엔드에 전송
            const newState = await sendAction(actionType, amount);
            
            // 2. UI 상태 업데이트
            gameState = newState;

            // 3. UI 렌더링
            renderGameUI();
            
            logMessage(`액션 처리 완료. (다음 턴 상태는 백엔드에서 반환됨)`, 'green');
            document.getElementById('bet-panel').classList.add('hidden');
        }

        // 게임 단계 진행 (버튼 클릭 시)
        async function advanceGamePhase() {
            logMessage(`다음 단계 진행 요청...`, 'purple');
            
            // 1. [Placeholder 호출] 백엔드에 단계 진행 요청
            const newState = await advanceGamePhaseBackend();
            
            // 2. UI 상태 업데이트
            gameState = newState;
            
            // 3. UI 렌더링
            renderGameUI();
            logMessage(`단계 진행 완료: ${getPhaseName(gameState.gamePhase)} 공개.`, 'green');

            // 쇼다운 후에는 다시 초기화 상태로 돌리기 위해 버튼 텍스트 변경
            if (gameState.gamePhase === 'showdown') {
                document.getElementById('next-phase-button').textContent = '게임 재시작';
            } else if (gameState.gamePhase === 'preflop') {
                 document.getElementById('next-phase-button').textContent = '다음 단계로 (Preflop)';
            } else {
                 document.getElementById('next-phase-button').textContent = `다음 단계로 (${getPhaseName(gameState.gamePhase)})`;
            }
        }
        
        // --- 4. 뷰 렌더링 (View Rendering) ---

        // 메인 렌더링 함수
        function renderGameUI() {
            renderCommunityCards();
            renderPlayers();
            renderControls();
            
            document.getElementById('pot-amount').textContent = formatChips(gameState.pot);
            
            const activePlayer = gameState.players[gameState.activePlayerIndex];
            const phaseText = getPhaseName(gameState.gamePhase);

            if (gameState.gamePhase === 'showdown') {
                 document.getElementById('game-message').innerHTML = `<span class="text-xl font-bold">${phaseText}</span><br>UI 시뮬레이션 종료. (승자 결정 로직 통합 필요)`;
            } else {
                document.getElementById('game-message').innerHTML = `<span class="text-xl font-bold">${phaseText}</span><br>${activePlayer.name} 님의 차례입니다.`;
            }
            
            // 컨트롤 패널의 사용자 상호작용은 항상 가능하게 둡니다.
        }
        
        function renderCommunityCards() {
            const container = document.getElementById('community-cards');
            // 커뮤니티 카드가 5장 미만일 경우 빈 카드 백을 추가하여 레이아웃 고정
            const cardCount = gameState.communityCards.length;
            let html = gameState.communityCards.map(card => getCardHTML(card)).join('');
            
            // 빈 카드 렌더링
            for (let i = 0; i < 5 - cardCount; i++) {
                html += getCardHTML(null, true); 
            }
            container.innerHTML = html;
        }

        function renderPlayers() {
            const container = document.getElementById('player-container');
            container.innerHTML = gameState.players.map((player, index) => {
                const isActive = index === gameState.activePlayerIndex;
                const statusText = player.has_folded ? '폴드' : (player.is_all_in ? '올인' : '활성');
                const statusColor = player.has_folded ? 'bg-gray-500' : (player.is_all_in ? 'bg-yellow-500' : 'bg-green-600');
                const activeRing = isActive ? 'border-4 border-yellow-400' : 'border-2 border-gray-700';
                
                // 홀 카드 렌더링 (사용자나 쇼다운 시에만 공개)
                let handHTML = player.hand.map(card => {
                    // 사용자 카드만 공개 (실제 룰)
                    const isHidden = !player.isUser && gameState.gamePhase !== 'showdown';
                    return getCardHTML(card, isHidden);
                }).join('');
                
                const betDisplay = player.current_bet > 0 ? 
                    `<div class="mt-1 text-sm font-bold text-red-300">베팅: ${formatChips(player.current_bet)}</div>` : '';
                
                return `
                    <div id="player-${index}" class="player-area player-${index} bg-poker-dark/90 p-3 rounded-xl shadow-lg ${activeRing} transition-all duration-300">
                        <div class="text-lg font-bold truncate">${player.name}</div>
                        <div class="text-sm font-medium ${player.chips <= 0 ? 'text-red-400' : 'text-yellow-300'}">${formatChips(player.chips)} 칩</div>
                        
                        <div class="flex justify-center space-x-1 mt-2 mb-2">
                            ${handHTML}
                        </div>
                        
                        ${betDisplay}

                        <!-- 상태 태그 -->
                        <div class="text-xs font-semibold ${statusColor} text-white px-2 py-0.5 rounded-full inline-block mt-1">
                            ${statusText}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderControls() {
            const user = gameState.players.find(p => p.isUser);
            if (!user) return;

            const slider = document.getElementById('bet-slider');
            const amountInput = document.getElementById('bet-amount');
            const raiseLabel = document.getElementById('raise-label');
            const callButtonLabel = document.getElementById('call-check-label');

            // 콜/체크 버튼 레이블 업데이트
            const amountToCall = gameState.currentRequiredBet - user.current_bet;
            if (amountToCall > 0) {
                callButtonLabel.textContent = `콜 (${formatChips(amountToCall)})`;
            } else {
                callButtonLabel.textContent = `체크 (Check)`;
            }

            // 슬라이더 및 입력 필드 업데이트
            slider.max = user.chips;
            slider.min = amountToCall;
            slider.value = amountToCall;

            const updateBetControls = () => {
                let betValue = parseInt(slider.value, 10);
                if (betValue < amountToCall) betValue = amountToCall;
                if (betValue > user.chips) betValue = user.chips;
                
                slider.value = betValue;
                amountInput.value = betValue;
                raiseLabel.textContent = formatChips(betValue);
            };

            slider.oninput = updateBetControls;
            amountInput.oninput = () => {
                let val = parseInt(amountInput.value, 10);
                if (isNaN(val)) val = 0;
                
                // 베팅액 유효성 검사
                if (val < amountToCall) val = amountToCall; 
                if (val > user.chips) val = user.chips;
                
                amountInput.value = val;
                slider.value = val;
                raiseLabel.textContent = formatChips(val);
            };

            updateBetControls(); // 초기 업데이트
        }
        
        // --- 유틸리티 함수 ---
        function getPhaseName(phase) {
            switch (phase) {
                case 'preflop': return '프리플랍 (Preflop)';
                case 'flop': return '플랍 (Flop)';
                case 'turn': return '턴 (Turn)';
                case 'river': return '리버 (River)';
                case 'showdown': return '쇼다운 (Showdown)';
                default: return '게임 시작 전';
            }
        }

        function logMessage(message, color = 'white') {
            const logElement = document.getElementById('game-log');
            const colorClass = {
                'yellow': 'text-yellow-300',
                'blue': 'text-blue-300',
                'green': 'text-green-400',
                'purple': 'text-purple-300',
                'white': 'text-white'
            }[color] || 'text-white';
            
            logElement.innerHTML += `<div class="${colorClass}">[${new Date().toLocaleTimeString('ko-KR')}] ${message}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        window.onload = function() {
            // 시작 화면 컨트롤 설정
            const buttons = document.querySelectorAll('.difficulty-btn');
            const startButton = document.getElementById('start-game-button');
            const statusText = document.getElementById('difficulty-status');
            
            buttons.forEach(button => {
                button.onclick = () => {
                    gameState.difficulty = button.dataset.difficulty;
                    statusText.textContent = `선택된 난이도: ${button.textContent} (UI 시뮬레이션)`;
                    startButton.disabled = false;
                    
                    buttons.forEach(btn => btn.classList.remove('border-yellow-400', 'border-4'));
                    button.classList.add('border-yellow-400', 'border-4');
                };
            });
            
            startButton.onclick = startGame;

            // 초기 로깅
            logMessage('UI 셸 준비 완료. 난이도를 선택하고 시작 버튼을 눌러 통합 테스트를 시작하세요.', 'yellow');
        };
    </script>
</body>
</html>